{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/Calculator.js","webpack:///./src/Exp.js","webpack:///./src/LazyValue.js","webpack:///./src/Range.js","webpack:///./src/RawValue.js","webpack:///./src/RefValue.js","webpack:///./src/UserFnExecutor.js","webpack:///./src/UserRawFnExecutor.js","webpack:///./src/col_str_2_int.js","webpack:///./src/exec_formula.js","webpack:///./src/expression_builder.js","webpack:///./src/find_all_cells_with_formulas.js","webpack:///./src/formulas-raw.js","webpack:///./src/formulas.js","webpack:///./src/getSanitizedSheetName.js","webpack:///./src/index.js","webpack:///./src/int_2_col_str.js","webpack:///./src/str_2_val.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,kBAAkB,mBAAO,CAAC,0CAAgB;AAC1C,qCAAqC,mBAAO,CAAC,gFAAmC;;AAEhF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,4B;;;;;;;;;;;;ACrFa;;AAEb,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,cAAc,mBAAO,CAAC,kCAAY;AAClC,kBAAkB,mBAAO,CAAC,0CAAgB;;AAE1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;AC1Na;;AAEb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNa;;AAEb,sBAAsB,mBAAO,CAAC,kDAAoB;AAClD,sBAAsB,mBAAO,CAAC,kDAAoB;AAClD,8BAA8B,mBAAO,CAAC,kEAA4B;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTa;;AAEb,8BAA8B,mBAAO,CAAC,kEAA4B;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ea;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;ACvCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBa;;AAEb;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA,E;;;;;;;;;;;;ACTa;;AAEb,2BAA2B,mBAAO,CAAC,4DAAyB;;AAE5D;AACA;;AAEA,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,qBAAqB,mBAAO,CAAC,gDAAmB;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,2CAA2C;AACnF;;;AAGA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrFA,YAAY,mBAAO,CAAC,8BAAU;AAC9B,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,uBAAuB,mBAAO,CAAC,oDAAqB;AACpD,0BAA0B,mBAAO,CAAC,0DAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA,C;;;;;;;;;;;;ACvIa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBa;;AAEb,sBAAsB,mBAAO,CAAC,kDAAoB;AAClD,sBAAsB,mBAAO,CAAC,kDAAoB;AAClD,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,cAAc,mBAAO,CAAC,kCAAY;AAClC,iBAAiB,mBAAO,CAAC,wCAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ga;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;AACA,SAAS;AACT,2BAA2B,4BAA4B;AACvD;AACA,2BAA2B,YAAY;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4BAA4B,IAAI;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACz3Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,sBAAsB,mBAAO,CAAC,kDAAoB;AAClD,sBAAsB,mBAAO,CAAC,kDAAoB;AAClD,qBAAqB,mBAAO,CAAC,gDAAmB;AAChD,qCAAqC,mBAAO,CAAC,gFAAmC;AAChF,mBAAmB,mBAAO,CAAC,4CAAiB;;AAE5C;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;ACxCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACbA,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,iBAAiB,mBAAO,CAAC,wCAAe;AACxC,kBAAkB,mBAAO,CAAC,0CAAgB;AAC1C,cAAc,mBAAO,CAAC,kCAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"xlsx-calc.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","\"use strict\";\r\n\r\nconst RawValue = require('./RawValue.js');\r\nconst str_2_val = require('./str_2_val.js');\r\nconst find_all_cells_with_formulas = require('./find_all_cells_with_formulas.js');\r\n\r\nclass Calculator {\r\n    \r\n    constructor(workbook, exec_formula) {\r\n        this.workbook = workbook;\r\n        this.expressions = [];\r\n        this.exec_formula = exec_formula;\r\n        this.variables = {};\r\n        this.formulas = find_all_cells_with_formulas(workbook, exec_formula);\r\n        for (let i = this.formulas.length - 1; i >= 0; i--) {\r\n            let exp = exec_formula.build_expression(this.formulas[i]);\r\n            this.expressions.push(exp);\r\n        }\r\n        this.calcNames();\r\n    }\r\n    \r\n    setVar(var_name, value) {\r\n        let variable = this.variables[var_name];\r\n        if (variable) {\r\n            variable.setValue(value);\r\n        } else {\r\n            this.expressions.forEach(exp => {\r\n                this.setVarOfExpression(exp, var_name, value);\r\n            });\r\n        }\r\n    }\r\n    \r\n    getVars() {\r\n        let vars = {};\r\n        for (let k in this.variables) {\r\n            vars[k] = this.variables[k].calc();\r\n        }\r\n        return vars;\r\n    }\r\n    \r\n    calcNames() {\r\n        if (!this.workbook || !this.workbook.Workbook || !this.workbook.Workbook.Names) {\r\n            return;\r\n        }\r\n        this.workbook.Workbook.Names.forEach(item => {\r\n            let val = this.getRef(item.Ref);\r\n            this.variables[item.Name] = val;\r\n            this.expressions.forEach(exp => {\r\n                this.setVarOfExpression(exp, item.Name);\r\n            });\r\n        });\r\n    }\r\n    \r\n    getRef(ref_name) {\r\n        if (!this.formulas.length) {\r\n            throw new Error(\"No formula found.\");\r\n        }\r\n        let first_formula = this.formulas[0];\r\n        let formula_ref = first_formula.formula_ref;\r\n        let formula = {\r\n            formula_ref: formula_ref,\r\n            wb: this.workbook,\r\n            exec_formula: this.exec_formula\r\n        };\r\n        return str_2_val(ref_name, formula);\r\n    }\r\n    \r\n    setVarOfExpression(exp, var_name, value) {\r\n        for (let i = 0; i < exp.args.length; i++) {\r\n            let arg = exp.args[i];\r\n            if (arg === var_name) {\r\n                exp.args[i] = this.variables[var_name] || (this.variables[var_name] = new RawValue(value));\r\n            } else if (typeof arg === 'object' && (arg.name === 'Expression' || arg.name === 'UserFn')) {\r\n                this.setVarOfExpression(arg, var_name, value);\r\n            }\r\n        }\r\n    }\r\n    \r\n    execute() {\r\n        this.expressions.forEach(exp => {\r\n            exp.update_cell_value();\r\n        });\r\n    }\r\n}\r\n\r\nmodule.exports = Calculator;","\"use strict\";\r\n\r\nconst RawValue = require('./RawValue.js');\r\nconst Range = require('./Range.js');\r\nconst str_2_val = require('./str_2_val.js');\r\n\r\nconst MS_PER_DAY = 24 * 60 * 60 * 1000;\r\n\r\nvar exp_id = 0;\r\n\r\nmodule.exports = function Exp(formula) {\r\n    var self = this;\r\n    self.id = ++exp_id;\r\n    self.args = [];\r\n    self.name = 'Expression';\r\n    self.update_cell_value = update_cell_value;\r\n    self.formula = formula;\r\n    \r\n    function update_cell_value() {\r\n        try {\r\n            if (Array.isArray(self.args) \r\n                    && self.args.length === 1\r\n                    && self.args[0] instanceof Range) {\r\n                throw Error('#VALUE!');\r\n            }\r\n            formula.cell.v = self.calc();\r\n            if (typeof(formula.cell.v) === 'string') {\r\n                formula.cell.t = 's';\r\n            }\r\n            else if (typeof(formula.cell.v) === 'number') {\r\n                formula.cell.t = 'n';\r\n            }\r\n        }\r\n        catch (e) {\r\n            var errorValues = {\r\n                '#NULL!': 0x00,\r\n                '#DIV/0!': 0x07,\r\n                '#VALUE!': 0x0F,\r\n                '#REF!': 0x17,\r\n                '#NAME?': 0x1D,\r\n                '#NUM!': 0x24,\r\n                '#N/A': 0x2A,\r\n                '#GETTING_DATA': 0x2B\r\n            };\r\n            if (errorValues[e.message] !== undefined) {\r\n                formula.cell.t = 'e';\r\n                formula.cell.w = e.message;\r\n                formula.cell.v = errorValues[e.message];\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        finally {\r\n            formula.status = 'done';\r\n        }\r\n    }\r\n    function isEmpty(value) {\r\n        return value === undefined || value === null || value === \"\";\r\n    }\r\n    \r\n    function checkVariable(obj) {\r\n        if (typeof obj.calc !== 'function') {\r\n            throw new Error('Undefined ' + obj);\r\n        }\r\n    }\r\n\r\n    function getCurrentCellIndex() {\r\n        return +self.formula.name.replace(/[^0-9]/g, '');\r\n    }\r\n    \r\n    function exec(op, args, fn) {\r\n        for (var i = 0; i < args.length; i++) {\r\n            if (args[i] === op) {\r\n                try {\r\n                    if (i===0 && op==='+') {\r\n                        checkVariable(args[i + 1]);\r\n                        let r = args[i + 1].calc();\r\n                        args.splice(i, 2, new RawValue(r));\r\n                    } else {\r\n                        checkVariable(args[i - 1]);\r\n                        checkVariable(args[i + 1]);\r\n\r\n                        let a = args[i - 1].calc();\r\n                        let b = args[i + 1].calc();\r\n                        if (Array.isArray(a)) {\r\n                            a = a[getCurrentCellIndex() - 1][0];\r\n                        }\r\n                        if (Array.isArray(b)) {\r\n                            b = b[getCurrentCellIndex() - 1][0];\r\n                        }\r\n\r\n                        let r = fn(a, b);\r\n                        args.splice(i - 1, 3, new RawValue(r));\r\n                        i--;\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // console.log('[Exp.js] - ' + formula.name + ': evaluating ' + formula.cell.f + '\\n' + e.message);\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function exec_minus(args) {\r\n        for (var i = args.length; i--;) {\r\n            if (args[i] === '-') {\r\n                checkVariable(args[i + 1]);\r\n                var b = args[i + 1].calc();\r\n                if (i > 0 && typeof args[i - 1] !== 'string') {\r\n                    args.splice(i, 1, '+');\r\n                    if (b instanceof Date) {\r\n                        b = Date.parse(b);\r\n                        checkVariable(args[i - 1]);\r\n                        var a = args[i - 1].calc();\r\n                        if (a instanceof Date) {\r\n                            a = Date.parse(a) / MS_PER_DAY;\r\n                            b = b / MS_PER_DAY;\r\n                            args.splice(i - 1, 1, new RawValue(a));\r\n                        }\r\n                    }\r\n                    args.splice(i + 1, 1, new RawValue(-b));\r\n                }\r\n                else {\r\n                    if (typeof b === 'string') {\r\n                        throw new Error('#VALUE!');\r\n                    }\r\n                    args.splice(i, 2, new RawValue(-b));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    self.calc = function() {\r\n        let args = self.args.concat();\r\n        exec_minus(args);\r\n        exec('^', args, function(a, b) {\r\n            return Math.pow(+a, +b);\r\n        });\r\n        exec('/', args, function(a, b) {\r\n            if (b == 0) {\r\n                throw Error('#DIV/0!');\r\n            }\r\n            return (+a) / (+b);\r\n        });\r\n        exec('*', args, function(a, b) {\r\n            return (+a) * (+b);\r\n        });\r\n        exec('+', args, function(a, b) {\r\n            if (a instanceof Date && typeof b === 'number') {\r\n                b = b * MS_PER_DAY;\r\n            }\r\n            return (+a) + (+b);\r\n        });\r\n        exec('&', args, function(a, b) {\r\n            return '' + a + b;\r\n        });\r\n        exec('<', args, function(a, b) {\r\n            return a < b;\r\n        });\r\n        exec('>', args, function(a, b) {\r\n            return a > b;\r\n        });\r\n        exec('>=', args, function(a, b) {\r\n            return a >= b;\r\n        });\r\n        exec('<=', args, function(a, b) {\r\n            return a <= b;\r\n        });\r\n        exec('<>', args, function(a, b) {\r\n            if (a instanceof Date && b instanceof Date) {\r\n                return a.getTime() !== b.getTime();\r\n            }\r\n            if (isEmpty(a) && isEmpty(b)) {\r\n                return false;\r\n            }\r\n            return a !== b;\r\n        });\r\n        exec('=', args, function(a, b) {\r\n            if (a instanceof Date && b instanceof Date) {\r\n                return a.getTime() === b.getTime();\r\n            }\r\n            if (isEmpty(a) && isEmpty(b)) {\r\n                return true;\r\n            }\r\n            if ((a == null && b === 0) || (a === 0 && b == null)) {\r\n                return true;\r\n            }\r\n            if (typeof a === 'string' && typeof b === 'string' && a.toLowerCase() === b.toLowerCase()) {\r\n                return true;\r\n            }\r\n            return a == b;\r\n        });\r\n        if (args.length == 1) {\r\n            if (typeof(args[0].calc) !== 'function') {\r\n                return args[0];\r\n            }\r\n            else {\r\n                return args[0].calc();\r\n            }\r\n        }\r\n    };\r\n\r\n    var last_arg;\r\n    self.push = function(buffer) {\r\n        if (buffer) {\r\n            var v = str_2_val(buffer, formula);\r\n            if (((v === '=') && (last_arg == '>' || last_arg == '<')) || (last_arg == '<' && v === '>')) {\r\n                self.args[self.args.length - 1] += v;\r\n            }\r\n            else {\r\n                self.args.push(v);\r\n            }\r\n            last_arg = v;\r\n            //console.log(self.id, '-->', v);\r\n        }\r\n    };\r\n};","\"use strict\";\r\n\r\nmodule.exports = function LazyValue(fn) {\r\n    this.calc = function() {\r\n        return fn();\r\n    };\r\n};\r\n","\"use strict\";\r\n\r\nconst col_str_2_int = require('./col_str_2_int.js');\r\nconst int_2_col_str = require('./int_2_col_str.js');\r\nconst getSanitizedSheetName = require('./getSanitizedSheetName.js');\r\n\r\nmodule.exports = function Range(str_expression, formula) {\r\n    this.calc = function() {\r\n        var range_expression, sheet_name, sheet;\r\n        if (str_expression.indexOf('!') != -1) {\r\n            var aux = str_expression.split('!');\r\n            sheet_name = getSanitizedSheetName(aux[0]);\r\n            range_expression = aux[1];\r\n        }\r\n        else {\r\n            sheet_name = formula.sheet_name;\r\n            range_expression = str_expression;\r\n        }\r\n        sheet = formula.wb.Sheets[sheet_name];\r\n        var arr = range_expression.split(':');\r\n        var min_row = parseInt(arr[0].replace(/^[A-Z]+/, ''), 10) || 0;\r\n        var str_max_row = arr[1].replace(/^[A-Z]+/, '');\r\n        var max_row;\r\n        if (str_max_row === '' && sheet['!ref']) {\r\n            str_max_row = sheet['!ref'].split(':')[1].replace(/^[A-Z]+/, '');\r\n        }\r\n        // the max is 1048576, but TLE\r\n        max_row = parseInt(str_max_row == '' ? '500000' : str_max_row, 10);\r\n        var min_col = col_str_2_int(arr[0]);\r\n        var max_col = col_str_2_int(arr[1]);\r\n        var matrix = [];\r\n        for (var i = min_row; i <= max_row; i++) {\r\n            var row = [];\r\n            matrix.push(row);\r\n            for (var j = min_col; j <= max_col; j++) {\r\n                var cell_name = int_2_col_str(j) + i;\r\n                var cell_full_name = sheet_name + '!' + cell_name;\r\n                var formula_ref = formula.formula_ref[cell_full_name];\r\n                if (formula_ref) {\r\n                    if (formula_ref.status === 'new') {\r\n                        formula.exec_formula(formula_ref);\r\n                    } else if (formula_ref.status === 'working') {\r\n                        if (formula_ref.cell.f.includes(formula.name)) {\r\n                            throw new Error('Circular ref');\r\n                        }\r\n                        formula.exec_formula(formula_ref);\r\n                    }\r\n                    if (sheet[cell_name].t === 'e') {\r\n                        row.push(sheet[cell_name]);\r\n                    }\r\n                    else {\r\n                        row.push(sheet[cell_name].v);\r\n                    }\r\n                }\r\n                else if (sheet[cell_name]) {\r\n                    if (sheet[cell_name].t === 'e') {\r\n                        row.push(sheet[cell_name]);\r\n                    }\r\n                    else {\r\n                        row.push(sheet[cell_name].v);\r\n                    }\r\n                }\r\n                else {\r\n                    row.push(null);\r\n                }\r\n            }\r\n        }\r\n        return matrix;\r\n    };\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = function RawValue(value) {\r\n    this.setValue = function(v) {\r\n        value = v;\r\n    };\r\n    this.calc = function() {\r\n        return value;\r\n    };\r\n};\r\n","\"use strict\";\r\n\r\nconst getSanitizedSheetName = require('./getSanitizedSheetName.js');\r\n\r\nmodule.exports = function RefValue(str_expression, formula) {\r\n    var self = this;\r\n    this.name = 'RefValue';\r\n    this.str_expression = str_expression;\r\n    this.formula = formula;\r\n\r\n    self.parseRef = function() {\r\n        var sheet, sheet_name, cell_name, cell_full_name;\r\n        if (str_expression.indexOf('!') != -1) {\r\n            var aux = str_expression.split('!');\r\n            sheet_name = getSanitizedSheetName(aux[0]);\r\n            sheet = formula.wb.Sheets[sheet_name];\r\n            cell_name = aux[1];\r\n        }\r\n        else {\r\n            sheet = formula.sheet;\r\n            sheet_name = formula.sheet_name;\r\n            cell_name = str_expression;\r\n        }\r\n        if (!sheet) {\r\n            throw Error(\"Sheet \" + sheet_name + \" not found.\");\r\n        }\r\n        cell_full_name = sheet_name + '!' + cell_name;\r\n        return {\r\n            sheet: sheet,\r\n            sheet_name: sheet_name,\r\n            cell_name: cell_name,\r\n            cell_full_name: cell_full_name\r\n        };\r\n    };\r\n\r\n    this.calc = function() {\r\n        var resolved_ref = self.parseRef();\r\n        var sheet = resolved_ref.sheet;\r\n        var cell_name = resolved_ref.cell_name;\r\n        var cell_full_name = resolved_ref.cell_full_name;\r\n        var ref_cell = sheet[cell_name];\r\n        if (!ref_cell) {\r\n            return null;\r\n        }\r\n        var formula_ref = formula.formula_ref[cell_full_name];\r\n        if (formula_ref) {\r\n            if (formula_ref.status === 'new') {\r\n                formula.exec_formula(formula_ref);\r\n                if (ref_cell.t === 'e') {\r\n                    console.log('ref is an error with new formula', cell_full_name, ref_cell.w);\r\n                    throw new Error(ref_cell.w);\r\n                }\r\n                return ref_cell.v;\r\n            }\r\n            else if (formula_ref.status === 'working') {\r\n                if (ref_cell.f.includes(formula.name)) {\r\n                    throw new Error('Circular ref');\r\n                }\r\n                formula.exec_formula(formula_ref);\r\n                return this.calc();\r\n            }\r\n            else if (formula_ref.status === 'done') {\r\n                if (ref_cell.t === 'e') {\r\n                    console.log('ref is an error after formula eval', cell_full_name, ref_cell.w);\r\n                    throw new Error(ref_cell.w);\r\n                }\r\n                return ref_cell.v;\r\n            }\r\n        }\r\n        else {\r\n            if (ref_cell.t === 'e') {\r\n                console.log('ref is an error with no formula', cell_name);\r\n                throw new Error(ref_cell.w);\r\n            }\r\n            return ref_cell.v;\r\n        }\r\n    };\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = function UserFnExecutor(user_function) {\r\n    var self = this;\r\n    self.name = 'UserFn';\r\n    self.args = [];\r\n    self.calc = function() {\r\n        var errorValues = {\r\n            '#NULL!': 0x00,\r\n            '#DIV/0!': 0x07,\r\n            '#VALUE!': 0x0F,\r\n            '#REF!': 0x17,\r\n            '#NAME?': 0x1D,\r\n            '#NUM!': 0x24,\r\n            '#N/A': 0x2A,\r\n            '#GETTING_DATA': 0x2B\r\n        }, result;\r\n        try {\r\n            result = user_function.apply(self, self.args.map(f=>f.calc()));\r\n        } catch (e) {\r\n            if (user_function.name === 'is_blank'\r\n                && errorValues[e.message] !== undefined) {\r\n                // is_blank applied to an error cell doesn't propagate the error\r\n                result = 0;\r\n            }\r\n            else if (user_function.name === 'iserror'\r\n                && errorValues[e.message] !== undefined) {\r\n                // iserror applied to an error doesn't propagate the error and returns true\r\n                result = true;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    self.push = function(buffer) {\r\n        self.args.push(buffer);\r\n    };\r\n};","\"use strict\";\r\n\r\nmodule.exports = function UserRawFnExecutor(user_function, formula) {\r\n    var self = this;\r\n    self.name = 'UserRawFn';\r\n    self.args = [];\r\n    self.calc = function() {\r\n        try {\r\n            return user_function.apply(self, self.args);\r\n        } catch(e) {\r\n            // debug\r\n            // console.log('----------------', user_function);\r\n            // console.log(formula.name);\r\n            // console.log(self);\r\n            throw e;\r\n        }\r\n    };\r\n    self.push = function(buffer) {\r\n        self.args.push(buffer);\r\n    };\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = function col_str_2_int(col_str) {\r\n    var r = 0;\r\n    var colstr = col_str.replace(/[0-9]+$/, '');\r\n    for (var i = colstr.length; i--;) {\r\n        r += Math.pow(26, colstr.length - i - 1) * (colstr.charCodeAt(i) - 64);\r\n    }\r\n    return r - 1;\r\n};","\"use strict\";\r\n\r\nconst expression_builder = require('./expression_builder.js');\r\n\r\nlet xlsx_Fx = {};\r\nlet xlsx_raw_Fx = {};\r\n\r\nimport_functions(require('./formulas.js'));\r\nimport_raw_functions(require('./formulas-raw.js'));\r\n\r\nfunction import_raw_functions(functions, opts) {\r\n    for (var key in functions) {\r\n        xlsx_raw_Fx[key] = functions[key];\r\n    }\r\n}\r\n\r\nfunction import_functions(formulajs, opts) {\r\n\r\n    opts = opts || {};\r\n    var prefix = opts.prefix || '';\r\n    for (var key in formulajs) {\r\n        var obj = formulajs[key];\r\n        if (typeof(obj) === 'function') {\r\n            if (opts.override || !xlsx_Fx[prefix + key]) {\r\n                xlsx_Fx[prefix + key] = obj;\r\n            }\r\n            // else {\r\n            //     console.log(prefix + key, 'already exists.');\r\n            //     console.log('  to override:');\r\n            //     console.log('    XLSX_CALC.import_functions(yourlib, {override: true})');\r\n            // }\r\n        }\r\n        else if (typeof(obj) === 'object') {\r\n            import_functions(obj, my_assign(opts, { prefix: key + '.' }));\r\n        }\r\n    }\r\n}\r\n\r\nfunction my_assign(dest, source) {\r\n    var obj = JSON.parse(JSON.stringify(dest));\r\n    for (var k in source) {\r\n        obj[k] = source[k];\r\n    }\r\n    return obj;\r\n}\r\n\r\nfunction build_expression(formula) {\r\n    return expression_builder(formula, {xlsx_Fx: xlsx_Fx, xlsx_raw_Fx: xlsx_raw_Fx});\r\n}\r\n\r\n\r\nfunction exec_formula(formula) {\r\n    /*console.log(formula.xlsx_Fx);\r\n    console.log(formula.exec_formula);\r\n    console.log(formula.cell);\r\n    console.log(formula.formula_ref);\r\n    console.log(formula.wb);*/\r\n    let root_exp = build_expression(formula);\r\n    root_exp.update_cell_value();\r\n}\r\n\r\nexec_formula.set_fx = function set_fx(name, fn) {\r\n    xlsx_Fx[name] = fn;\r\n};\r\n\r\nexec_formula.exec_fx = function exec_fx(name, args) {\r\n    return xlsx_Fx[name].apply(this, args);\r\n};\r\n\r\nexec_formula.localizeFunctions = function(dic) {\r\n    for (let newName in dic) {\r\n        let oldName = dic[newName];\r\n        if (xlsx_Fx[oldName]) {\r\n            xlsx_Fx[newName] = xlsx_Fx[oldName];\r\n        }\r\n        if (xlsx_raw_Fx[oldName]) {\r\n            xlsx_raw_Fx[newName] = xlsx_raw_Fx[oldName];\r\n        }\r\n    }\r\n};\r\n\r\nexec_formula.import_functions = import_functions;\r\nexec_formula.import_raw_functions = import_raw_functions;\r\nexec_formula.build_expression = build_expression;\r\nexec_formula.xlsx_Fx = xlsx_Fx;\r\nmodule.exports = exec_formula;\r\n","const Exp = require('./Exp.js');\r\nconst RawValue = require('./RawValue.js');\r\nconst UserFnExecutor = require('./UserFnExecutor.js');\r\nconst UserRawFnExecutor = require('./UserRawFnExecutor.js');\r\nconst common_operations = {\r\n    '*': 'multiply',\r\n    '+': 'plus',\r\n    '-': 'minus',\r\n    '/': 'divide',\r\n    '^': 'power',\r\n    '&': 'concat',\r\n    '<': 'lt',\r\n    '>': 'gt',\r\n    '=': 'eq'\r\n};\r\n\r\nmodule.exports = function expression_builder(formula, opts) {\r\n    formula.status = 'working';\r\n\r\n    var xlsx_Fx = opts.xlsx_Fx || {};\r\n    var xlsx_raw_Fx = opts.xlsx_raw_Fx || {};\r\n\r\n    var root_exp;\r\n    var str_formula = formula.cell.f;\r\n    if (str_formula[0] == '=') {\r\n        str_formula = str_formula.substr(1);\r\n    }\r\n    var exp_obj = root_exp = new Exp(formula);\r\n    var buffer = '',\r\n        was_string = false;\r\n    var fn_stack = [{\r\n        exp: exp_obj\r\n    }];\r\n\r\n    /**\r\n     * state pattern in functional way\r\n     */\r\n    function string(char) {\r\n        if (char === '\"') {\r\n            exp_obj.push(new RawValue(buffer));\r\n            was_string = true;\r\n            buffer = '';\r\n            state = start;\r\n        } else {\r\n            buffer += char;\r\n        }\r\n    }\r\n\r\n    function single_quote(char) {\r\n        if (char === \"'\") {\r\n            state = start;\r\n        }\r\n        buffer += char;\r\n    }\r\n\r\n    function ini_parentheses() {\r\n        var o, trim_buffer = buffer.trim(),\r\n            special = xlsx_Fx[trim_buffer];\r\n        var special_raw = xlsx_raw_Fx[trim_buffer];\r\n        if (special_raw) {\r\n            special = new UserRawFnExecutor(special_raw, formula);\r\n        }\r\n        else if (special) {\r\n            special = new UserFnExecutor(special, formula);\r\n        }\r\n        else if (trim_buffer) {\r\n            //Error: \"Worksheet 1\"!D145: Function INDEX not found\r\n            throw new Error('\"' + formula.sheet_name + '\"!' + formula.name + ': Function ' + buffer + ' not found');\r\n        }\r\n        o = new Exp(formula);\r\n        fn_stack.push({\r\n            exp: o,\r\n            special: special\r\n        });\r\n        exp_obj = o;\r\n        buffer = '';\r\n    }\r\n\r\n    function end_parentheses() {\r\n        var v, stack = fn_stack.pop();\r\n        exp_obj = stack.exp;\r\n        exp_obj.push(buffer);\r\n        v = exp_obj;\r\n        buffer = '';\r\n        exp_obj = fn_stack[fn_stack.length - 1].exp;\r\n        if (stack.special) {\r\n            stack.special.push(v);\r\n            exp_obj.push(stack.special);\r\n        }\r\n        else {\r\n            exp_obj.push(v);\r\n        }\r\n    }\r\n\r\n    function add_operation(char) {\r\n        if (!was_string) {\r\n            exp_obj.push(buffer);\r\n        }\r\n        was_string = false;\r\n        exp_obj.push(char);\r\n        buffer = '';\r\n    }\r\n\r\n    function start(char) {\r\n        if (char === '\"') {\r\n            state = string;\r\n            buffer = '';\r\n        } else if (char === \"'\") {\r\n            state = single_quote;\r\n            buffer = \"'\";\r\n        } else if (char === '(') {\r\n            ini_parentheses();\r\n        } else if (char === ')') {\r\n            end_parentheses();\r\n        } else if (common_operations[char]) {\r\n            add_operation(char);\r\n        } else if (char === ',' && fn_stack[fn_stack.length - 1].special) {\r\n            was_string = false;\r\n            fn_stack[fn_stack.length - 1].exp.push(buffer);\r\n            fn_stack[fn_stack.length - 1].special.push(fn_stack[fn_stack.length - 1].exp);\r\n            fn_stack[fn_stack.length - 1].exp = exp_obj = new Exp(formula);\r\n            buffer = '';\r\n        } else if (char !== ' ') {\r\n            buffer += char;\r\n        }\r\n    }\r\n    \r\n    var state = start;\r\n\r\n    for (var i = 0; i < str_formula.length; i++) {\r\n        state(str_formula[i]);\r\n    }\r\n    root_exp.push(buffer);\r\n    return root_exp;\r\n\r\n}","\"use strict\";\r\n\r\nmodule.exports = function find_all_cells_with_formulas(wb, exec_formula) {\r\n    let formula_ref = {};\r\n    let cells = [];\r\n    for (let sheet_name in wb.Sheets) {\r\n        let sheet = wb.Sheets[sheet_name];\r\n        for (let cell_name in sheet) {\r\n            if (sheet[cell_name] && sheet[cell_name].f) {\r\n                let formula = formula_ref[sheet_name + '!' + cell_name] = {\r\n                    formula_ref: formula_ref,\r\n                    wb: wb,\r\n                    sheet: sheet,\r\n                    sheet_name: sheet_name,\r\n                    cell: sheet[cell_name],\r\n                    name: cell_name,\r\n                    status: 'new',\r\n                    exec_formula: exec_formula\r\n                };\r\n                cells.push(formula);\r\n            }\r\n        }\r\n    }\r\n    return cells;\r\n};\r\n","\"use strict\";\r\n\r\nconst int_2_col_str = require('./int_2_col_str.js');\r\nconst col_str_2_int = require('./col_str_2_int.js');\r\nconst RawValue = require('./RawValue.js');\r\nconst Range = require('./Range.js');\r\nconst RefValue = require('./RefValue.js');\r\n\r\nfunction raw_offset(cell_ref, rows, columns, height, width) {\r\n    height = (height || new RawValue(1)).calc();\r\n    width = (width || new RawValue(1)).calc();\r\n    if (cell_ref.args.length === 1 && cell_ref.args[0].name === 'RefValue') {\r\n        var ref_value = cell_ref.args[0];\r\n        var parsed_ref = ref_value.parseRef();\r\n        var col = col_str_2_int(parsed_ref.cell_name) + columns.calc();\r\n        var col_str = int_2_col_str(col);\r\n        var row = +parsed_ref.cell_name.replace(/^[A-Z]+/g, '') + rows.calc();\r\n        var cell_name = parsed_ref.sheet_name + '!' + col_str + row;\r\n        if (height === 1 && width === 1) {\r\n            return new RefValue(cell_name, ref_value.formula).calc();\r\n        }\r\n        else {\r\n            var end_range_col = int_2_col_str(col + width - 1);\r\n            var end_range_row = row + height - 1;\r\n            var end_range = end_range_col + end_range_row;\r\n            var str_expression = cell_name + ':' + end_range;\r\n            return new Range(str_expression, ref_value.formula).calc();\r\n        }\r\n    }\r\n}\r\n\r\nfunction iferror(cell_ref, onerrorvalue) {\r\n    try {\r\n        var value = cell_ref.calc();\r\n        if (typeof value === 'number' && (isNaN(value) || value === Infinity || value === -Infinity)) {\r\n            return onerrorvalue.calc();\r\n        }\r\n        return value;\r\n    } catch(e) {\r\n        return onerrorvalue.calc();\r\n    }\r\n}\r\n\r\nfunction _if(condition, _then, _else) {\r\n    if (condition.calc()) {\r\n        // console.log(condition.formula.name)\r\n        // if (condition.formula.name === 'P40') {\r\n        //     console.log('P40 =', _then.calc());\r\n        //     console.log(' -->', _then.args[1].calc());\r\n        // }\r\n        return _then.calc();\r\n    }\r\n    else {\r\n        if (typeof _else === 'undefined') {\r\n            return false;\r\n        } else {\r\n            return _else.calc();\r\n        }\r\n    }\r\n}\r\n\r\nfunction and() {\r\n    for (var i = 0; i < arguments.length; i++) {\r\n        if(!arguments[i].calc()) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction _or() {\r\n    for (var i = 0; i < arguments.length; i++) {\r\n        if(arguments[i].calc()) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction transpose(expressionWithRange) {\r\n    let range = expressionWithRange.args[0];\r\n    // console.log(expressionWithRange.args[0])\r\n    // console.log(expressionWithRange.formula.wb.Sheets.Sheet1)\r\n    // console.log(range.calc())\r\n    let matrix = range.calc();\r\n    let cellName = expressionWithRange.formula.name;\r\n    let colRow = cellName.match(/([A-Z]+)([0-9]+)/);\r\n    let sheet = expressionWithRange.formula.sheet;\r\n    // console.log(colRow[1], colRow[2]);\r\n    // console.log(col_str_2_int(colRow[1]));\r\n    let colNumber = col_str_2_int(colRow[1]);\r\n    let rowNumber = +colRow[2];\r\n    for (let i = 0; i < matrix.length; i++) {\r\n        let matrixRow = matrix[i];\r\n        for (let j = 0; j < matrixRow.length; j++) {\r\n            let destinationColumn = colNumber + i;\r\n            let destinationRow = rowNumber + j;\r\n            let value = matrixRow[j];\r\n            // console.log(int_2_col_str(destinationColumn), destinationRow, value);\r\n            sheet[int_2_col_str(destinationColumn) + destinationRow].v = value;\r\n        }\r\n    }\r\n    // console.log(expressionWithRange.formula.name)\r\n    return matrix[0][0];\r\n}\r\n\r\nmodule.exports = {\r\n    'OFFSET': raw_offset,\r\n    'IFERROR': iferror,\r\n    'IF': _if,\r\n    'AND': and,\r\n    'OR': _or,\r\n    'TRANSPOSE': transpose\r\n};\r\n","\"use strict\";\r\n\r\n// +---------------------+\r\n// | FORMULAS REGISTERED |\r\n// +---------------------+\r\nlet formulas = {\r\n    'FLOOR': Math.floor,\r\n    '_xlfn.FLOOR.MATH': Math.floor,\r\n    'FLOOR.MATH': Math.floor,\r\n    'ABS': Math.abs,\r\n    'SQRT': Math.sqrt,\r\n    'VLOOKUP': vlookup,\r\n    'MAX': max,\r\n    'SUM': sum,\r\n    'MIN': min,\r\n    'CONCATENATE': concatenate,\r\n    'PMT': pmt,\r\n    'COUNTA': counta,\r\n    'IRR': irr,\r\n    'NORM.INV': normsInv,\r\n    '_xlfn.NORM.INV': normsInv,\r\n    'STDEV': stDeviation,\r\n    'AVERAGE': avg,\r\n    'EXP': EXP,\r\n    'LN': Math.log,\r\n    '_xlfn.VAR.P': var_p,\r\n    'VAR.P': var_p,\r\n    '_xlfn.COVARIANCE.P': covariance_p,\r\n    'COVARIANCE.P': covariance_p,\r\n    'TRIM': trim,\r\n    'LEN': len,\r\n    'ISBLANK': is_blank,\r\n    'HLOOKUP': hlookup,\r\n    'INDEX': index,\r\n    'MATCH': match,\r\n    'SUMPRODUCT': sumproduct,\r\n    'ISNUMBER': isnumber,\r\n    'TODAY': today,\r\n    'ISERROR': iserror,\r\n    'TIME': time,\r\n    'DAY': day,\r\n    'MONTH': month,\r\n    'YEAR': year,\r\n    'RIGHT': right,\r\n    'LEFT': left,\r\n    'IFS': ifs,\r\n    'ROUND': round,\r\n    'CORREL': correl, // missing test\r\n    'SUMIF': sumif, // missing test,\r\n    'CHOOSE': choose,\r\n    'SUBSTITUTE': substitute,\r\n    'CEILING': ceiling,\r\n    'XIRR': xirr,\r\n};\r\n\r\nfunction choose(option) {\r\n    return arguments[option];\r\n}\r\n\r\nfunction sumif(){\r\n\r\n    let elementToSum = arguments[1];\r\n    let sumResult = 0;\r\n\r\n    [].slice.call(arguments)[0][0].forEach((elt,key) =>{\r\n        \r\n        if (elt!==null){\r\n            //if the element is not a string but a number, number has no replace function, so converting to string.\r\n            elt = elt.toString();\r\n            if( elt.replace(/\\'/g, \"\") === elementToSum){\r\n                if (!isNaN([].slice.call(arguments)[2][0][key])){\r\n                    sumResult += [].slice.call(arguments)[2][0][key]\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return sumResult\r\n}\r\n\r\nfunction correl(a,b){\r\n\r\n    a = getArrayOfNumbers(a);\r\n    b = getArrayOfNumbers(b);\r\n\r\n    if (a.length !== b.length) {\r\n        return 'N/D';\r\n    }\r\n    var inv_n = 1.0 / (a.length-1);\r\n    var avg_a = sum.apply(this, a) / a.length;\r\n    var avg_b = sum.apply(this, b) / b.length;\r\n    var s = 0.0;\r\n    var sa = 0;\r\n    var sb=0;\r\n    for (var i = 0; i < a.length; i++) {\r\n        s += (a[i] - avg_a) * (b[i] - avg_b);\r\n\r\n        sa+=Math.pow(a[i],2);\r\n        sb+=Math.pow(b[i],2);\r\n    }\r\n\r\n    sa=Math.sqrt(sa/inv_n);\r\n    sb=Math.sqrt(sb/inv_n);\r\n\r\n    return s / (inv_n*sa*sb);\r\n}\r\n\r\nfunction round(value, decimalPlaces) {\r\n    if (arguments.length === 0) throw new Error(\"Err:511\");\r\n    if (arguments.length === 1) return Math.round(value);\r\n    let roundMeasure = Math.pow(10, decimalPlaces);\r\n    return Math.round(roundMeasure*value)/roundMeasure\r\n}\r\n\r\nfunction today() {\r\n    var today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    return today;\r\n}\r\nfunction xirr() {\r\n    return 4;\r\n}\r\nfunction isnumber(x) {\r\n    return !isNaN(x);\r\n}\r\n\r\nfunction sumproduct() {\r\n    var parseNumber = function (string) {\r\n        if (string === undefined || string === '' || string === null) {\r\n            return 0;\r\n        }\r\n        if (!isNaN(string)) {\r\n            return parseFloat(string);\r\n        }\r\n        return 0;\r\n    },\r\n    consistentSizeRanges = function (matrixArray) {\r\n        var getRowCount = function(matrix) {\r\n                return matrix.length;\r\n            },\r\n            getColCount = function(matrix) {\r\n                return matrix[0].length;\r\n            },\r\n            rowCount = getRowCount(matrixArray[0]),\r\n            colCount = getColCount(matrixArray[0]);\r\n\r\n        for (var i = 1; i < matrixArray.length; i++) {\r\n            if (getRowCount(matrixArray[i]) !== rowCount\r\n                || getColCount(matrixArray[i]) !== colCount) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    if (!arguments || arguments.length === 0) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    if (!consistentSizeRanges(arguments)) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    // throw error if any of the cells passed in arguments is in error\r\n    for (var i = 0; i < arguments.length; i++) {\r\n        var row = arguments[i];\r\n        if (Array.isArray(row)) {\r\n            for (var j = 0; j < row.length; j++) {\r\n                var col = row[j];\r\n                if (Array.isArray(col)) {\r\n                    for (var k = 0; k < col.length; k++) {\r\n                        var cell = col[k];\r\n                        if (cell && typeof cell === 'object' && cell.t === 'e') {\r\n                            throw Error(cell.w);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    var cell = col;\r\n                    if (cell && typeof cell === 'object' && cell.t === 'e') {\r\n                        throw Error(cell.w);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var cell = row;\r\n            if (cell && typeof cell === 'object' && cell.t === 'e') {\r\n                throw Error(cell.w);\r\n            }\r\n        }\r\n    }\r\n\r\n    var arrays = arguments.length + 1;\r\n    var result = 0;\r\n    var product;\r\n    var k;\r\n    var _i;\r\n    var _ij;\r\n    for (var i = 0; i < arguments[0].length; i++) {\r\n        if (!(arguments[0][i] instanceof Array)) {\r\n            product = 1;\r\n            for (k = 1; k < arrays; k++) {\r\n                _i = parseNumber(arguments[k - 1][i]);\r\n\r\n                product *= _i;\r\n            }\r\n            result += product;\r\n        } else {\r\n            for (var j = 0; j < arguments[0][i].length; j++) {\r\n                product = 1;\r\n                for (k = 1; k < arrays; k++) {\r\n                    _ij = parseNumber(arguments[k - 1][i][j]);\r\n\r\n                    product *= _ij;\r\n                }\r\n                result += product;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction match_less_than_or_equal(matrix, lookupValue) {\r\n    var index;\r\n    var indexValue;\r\n    for (var idx = 0; idx < matrix.length; idx++) {\r\n        if (matrix[idx] === lookupValue) {\r\n            return idx + 1;\r\n        } else if (matrix[idx] < lookupValue) {\r\n            if (!indexValue) {\r\n                index = idx + 1;\r\n                indexValue = matrix[idx];\r\n            } else if (matrix[idx] > indexValue) {\r\n                index = idx + 1;\r\n                indexValue = matrix[idx];\r\n            }\r\n        }\r\n    }\r\n    if (!index) {\r\n        throw Error('#N/A');\r\n    }\r\n    return index;\r\n}\r\n\r\nfunction match_exactly_string(matrix, lookupValue) {\r\n    for (var idx = 0; idx < matrix.length; idx++) {\r\n        lookupValue = lookupValue.replace(/\\?/g, '.');\r\n        if (Array.isArray(matrix[idx])) {\r\n            if (matrix[idx].length === 1\r\n                && typeof matrix[idx][0] === 'string') {\r\n                    if (matrix[idx][0].toLowerCase() === lookupValue.toLowerCase()) {\r\n                        return idx + 1;\r\n                    }\r\n                }\r\n        } else if (typeof matrix[idx] === 'string') {\r\n            if (matrix[idx].toLowerCase() === lookupValue.toLowerCase()) {\r\n                return idx + 1;\r\n            }\r\n        }\r\n\r\n    }\r\n    throw Error('#N/A');\r\n}\r\n\r\nfunction match_exactly_non_string(matrix, lookupValue) {\r\n    for (var idx = 0; idx < matrix.length; idx++) {\r\n        if (Array.isArray(matrix[idx])) {\r\n            if (matrix[idx].length === 1) {\r\n                if (matrix[idx][0] === lookupValue) {\r\n                    return idx + 1;\r\n                }\r\n            }\r\n        } else if (matrix[idx] === lookupValue) {\r\n            return idx + 1;\r\n        }\r\n    }\r\n    throw Error('#N/A');\r\n}\r\n\r\n// +---------------------+\r\n// | THE IMPLEMENTATIONS |\r\n// +---------------------+\r\n\r\n\r\nfunction match_greater_than_or_equal(matrix, lookupValue) {\r\n    var index;\r\n    var indexValue;\r\n    for (var idx = 0; idx < matrix.length; idx++) {\r\n        if (Array.isArray(matrix[idx]) && matrix[idx].length > 0) {\r\n            // For array in column\r\n            if (matrix[idx][0] === lookupValue) {\r\n                return idx + 1;\r\n            } else if (matrix[idx][0] > lookupValue) {\r\n                if (!indexValue) {\r\n                    index = idx + 1;\r\n                    indexValue = matrix[idx][0];\r\n                } else if (matrix[idx][0] < indexValue) {\r\n                    index = idx + 1;\r\n                    indexValue = matrix[idx][0];\r\n                }\r\n            }\r\n        } else {\r\n            // For array in row\r\n            if (matrix[idx] === lookupValue) {\r\n                return idx + 1;\r\n            } else if (matrix[idx] > lookupValue) {\r\n                if (!indexValue) {\r\n                    index = idx + 1;\r\n                    indexValue = matrix[idx];\r\n                } else if (matrix[idx] < indexValue) {\r\n                    index = idx + 1;\r\n                    indexValue = matrix[idx];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!index) {\r\n        throw Error('#N/A');\r\n    }\r\n    return index;\r\n}\r\n\r\nfunction match(lookupValue, matrix, matchType) {\r\n    if (Array.isArray(matrix)\r\n        && matrix.length === 1\r\n        && Array.isArray(matrix[0])) {\r\n        matrix = matrix[0];\r\n    }\r\n    if (!lookupValue && !matrix) {\r\n        throw Error('#N/A');\r\n    }\r\n    if (arguments.length === 2) {\r\n        matchType = 1;\r\n    }\r\n    if (!(matrix instanceof Array)) {\r\n        throw Error('#N/A');\r\n    }\r\n    if (matchType === 0) {\r\n        if (typeof lookupValue === 'string') {\r\n            return match_exactly_string(matrix, lookupValue);\r\n        } else {\r\n            return match_exactly_non_string(matrix, lookupValue);\r\n        }\r\n    } else if (matchType === 1) {\r\n        return match_less_than_or_equal(matrix, lookupValue);\r\n    } else if (matchType === -1) {\r\n        return match_greater_than_or_equal(matrix, lookupValue);\r\n    } else {\r\n        throw Error('#N/A');\r\n    }\r\n}\r\n\r\nfunction index(matrix, row_num, column_num) {\r\n    if (row_num <= matrix.length) {\r\n        var row = matrix[row_num - 1];\r\n        if (Array.isArray(row)) {\r\n            if (!column_num) {\r\n                return row;\r\n            } else if (column_num <= row.length) {\r\n                return row[column_num - 1];\r\n            }\r\n        } else {\r\n            return matrix[row_num];\r\n        }\r\n    }\r\n    throw Error('#REF!');\r\n}\r\n\r\n// impl ported from https://github.com/FormulaPages/hlookup\r\nfunction hlookup(needle, table, index, exactmatch) {\r\n    if (typeof needle === \"undefined\" || (0, is_blank)(needle)) {\r\n        throw Error('#N/A');\r\n    }\r\n\r\n    index = index || 0;\r\n    let row = table[0], i, searchingFor;\r\n\r\n    if (typeof needle === 'string') {\r\n        searchingFor = needle.toLowerCase();\r\n        for (i = 0; i < row.length; i++) {\r\n            if (exactmatch && row[i] === searchingFor || row[i].toLowerCase().indexOf(searchingFor) !== -1) {\r\n                return index < table.length + 1 ? table[index - 1][i] : table[0][i];\r\n            }\r\n        }\r\n    } else {\r\n        searchingFor = needle;\r\n        for (i = 0; i < row.length; i++) {\r\n            if (exactmatch && row[i] === searchingFor || row[i] === searchingFor) {\r\n                return index < table.length + 1 ? table[index - 1][i] : table[0][i];\r\n            }\r\n        }\r\n    }\r\n    throw Error('#N/A');\r\n}\r\n\r\nfunction len(a) {\r\n    return ('' + a).length;\r\n}\r\n\r\nfunction trim(a) {\r\n    return ('' + a).trim();\r\n}\r\n\r\nfunction is_blank(a) {\r\n    // console.log(a)\r\n    return !a;\r\n}\r\n\r\nfunction covariance_p(a, b) {\r\n    a = getArrayOfNumbers(a);\r\n    b = getArrayOfNumbers(b);\r\n    if (a.length != b.length) {\r\n        return 'N/D';\r\n    }\r\n    var inv_n = 1.0 / a.length;\r\n    var avg_a = sum.apply(this, a) / a.length;\r\n    var avg_b = sum.apply(this, b) / b.length;\r\n    var s = 0.0;\r\n    for (var i = 0; i < a.length; i++) {\r\n        s += (a[i] - avg_a) * (b[i] - avg_b);\r\n    }\r\n    return s * inv_n;\r\n}\r\n\r\nfunction getArrayOfNumbers(range) {\r\n    var arr = [];\r\n    for (var i = 0; i < range.length; i++) {\r\n        var arg = range[i];\r\n        if (Array.isArray(arg)) {\r\n            var matrix = arg;\r\n            for (var j = matrix.length; j--;) {\r\n                if (typeof(matrix[j]) == 'number') {\r\n                    arr.push(matrix[j]);\r\n                }\r\n                else if (Array.isArray(matrix[j])) {\r\n                    for (var k = matrix[j].length; k--;) {\r\n                        if (typeof(matrix[j][k]) == 'number') {\r\n                            arr.push(matrix[j][k]);\r\n                        }\r\n                    }\r\n                }\r\n                // else {\r\n                //   wtf is that?\r\n                // }\r\n            }\r\n        }\r\n        else {\r\n            if (typeof(arg) == 'number') {\r\n                arr.push(arg);\r\n            }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nfunction var_p() {\r\n    var average = avg.apply(this, arguments);\r\n    var s = 0.0;\r\n    var c = 0;\r\n    for (var i = 0; i < arguments.length; i++) {\r\n        var arg = arguments[i];\r\n        if (Array.isArray(arg)) {\r\n            var matrix = arg;\r\n            for (var j = matrix.length; j--;) {\r\n                for (var k = matrix[j].length; k--;) {\r\n                    if (matrix[j][k] !== null && matrix[j][k] !== undefined) {\r\n                        s += Math.pow(matrix[j][k] - average, 2);\r\n                        c++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            s += Math.pow(arg - average, 2);\r\n            c++;\r\n        }\r\n    }\r\n    return s / c;\r\n}\r\n\r\nfunction EXP(n) {\r\n    return Math.pow(Math.E, n);\r\n}\r\n\r\nfunction avg() {\r\n    return sum.apply(this, arguments) / counta.apply(this, arguments);\r\n}\r\n\r\nfunction stDeviation() {\r\n    var array = getArrayOfNumbers(arguments);\r\n\r\n    function _mean(array) {\r\n        return array.reduce(function(a, b) {\r\n            return a + b;\r\n        }) / array.length;\r\n    }\r\n    var mean = _mean(array),\r\n        dev = array.map(function(itm) {\r\n            return (itm - mean) * (itm - mean);\r\n        });\r\n    return Math.sqrt(dev.reduce(function(a, b) {\r\n        return a + b;\r\n    }) / (array.length - 1));\r\n}\r\n\r\n/// Original C++ implementation found at http://www.wilmott.com/messageview.cfm?catid=10&threadid=38771\r\n/// C# implementation found at http://weblogs.asp.net/esanchez/archive/2010/07/29/a-quick-and-dirty-implementation-of-excel-norminv-function-in-c.aspx\r\n/*\r\n *     Compute the quantile function for the normal distribution.\r\n *\r\n *     For small to moderate probabilities, algorithm referenced\r\n *     below is used to obtain an initial approximation which is\r\n *     polished with a final Newton step.\r\n *\r\n *     For very large arguments, an algorithm of Wichura is used.\r\n *\r\n *  REFERENCE\r\n *\r\n *     Beasley, J. D. and S. G. Springer (1977).\r\n *     Algorithm AS 111: The percentage points of the normal distribution,\r\n *     Applied Statistics, 26, 118-121.\r\n *\r\n *      Wichura, M.J. (1988).\r\n *      Algorithm AS 241: The Percentage Points of the Normal Distribution.\r\n *      Applied Statistics, 37, 477-484.\r\n */\r\nfunction normsInv(p, mu, sigma) {\r\n    if (p < 0 || p > 1) {\r\n        throw \"The probality p must be bigger than 0 and smaller than 1\";\r\n    }\r\n    if (sigma < 0) {\r\n        throw \"The standard deviation sigma must be positive\";\r\n    }\r\n\r\n    if (p == 0) {\r\n        return -Infinity;\r\n    }\r\n    if (p == 1) {\r\n        return Infinity;\r\n    }\r\n    if (sigma == 0) {\r\n        return mu;\r\n    }\r\n\r\n    var q, r, val;\r\n\r\n    q = p - 0.5;\r\n\r\n    /*-- use AS 241 --- */\r\n    /* double ppnd16_(double *p, long *ifault)*/\r\n    /*      ALGORITHM AS241  APPL. STATIST. (1988) VOL. 37, NO. 3\r\n            Produces the normal deviate Z corresponding to a given lower\r\n            tail area of P; Z is accurate to about 1 part in 10**16.\r\n    */\r\n    if (Math.abs(q) <= .425) { /* 0.075 <= p <= 0.925 */\r\n        r = .180625 - q * q;\r\n        val =\r\n            q * (((((((r * 2509.0809287301226727 +\r\n                            33430.575583588128105) * r + 67265.770927008700853) * r +\r\n                        45921.953931549871457) * r + 13731.693765509461125) * r +\r\n                    1971.5909503065514427) * r + 133.14166789178437745) * r +\r\n                3.387132872796366608) / (((((((r * 5226.495278852854561 +\r\n                        28729.085735721942674) * r + 39307.89580009271061) * r +\r\n                    21213.794301586595867) * r + 5394.1960214247511077) * r +\r\n                687.1870074920579083) * r + 42.313330701600911252) * r + 1);\r\n    }\r\n    else { /* closer than 0.075 from {0,1} boundary */\r\n\r\n        /* r = min(p, 1-p) < 0.075 */\r\n        if (q > 0)\r\n            r = 1 - p;\r\n        else\r\n            r = p;\r\n\r\n        r = Math.sqrt(-Math.log(r));\r\n        /* r = sqrt(-log(r))  <==>  min(p, 1-p) = exp( - r^2 ) */\r\n\r\n        if (r <= 5) { /* <==> min(p,1-p) >= exp(-25) ~= 1.3888e-11 */\r\n            r += -1.6;\r\n            val = (((((((r * 7.7454501427834140764e-4 +\r\n                                .0227238449892691845833) * r + .24178072517745061177) *\r\n                            r + 1.27045825245236838258) * r +\r\n                        3.64784832476320460504) * r + 5.7694972214606914055) *\r\n                    r + 4.6303378461565452959) * r +\r\n                1.42343711074968357734) / (((((((r *\r\n                                1.05075007164441684324e-9 + 5.475938084995344946e-4) *\r\n                            r + .0151986665636164571966) * r +\r\n                        .14810397642748007459) * r + .68976733498510000455) *\r\n                    r + 1.6763848301838038494) * r +\r\n                2.05319162663775882187) * r + 1);\r\n        }\r\n        else { /* very close to  0 or 1 */\r\n            r += -5;\r\n            val = (((((((r * 2.01033439929228813265e-7 +\r\n                                2.71155556874348757815e-5) * r +\r\n                            .0012426609473880784386) * r + .026532189526576123093) *\r\n                        r + .29656057182850489123) * r +\r\n                    1.7848265399172913358) * r + 5.4637849111641143699) *\r\n                r + 6.6579046435011037772) / (((((((r *\r\n                            2.04426310338993978564e-15 + 1.4215117583164458887e-7) *\r\n                        r + 1.8463183175100546818e-5) * r +\r\n                    7.868691311456132591e-4) * r + .0148753612908506148525) * r + .13692988092273580531) * r +\r\n                .59983220655588793769) * r + 1);\r\n        }\r\n\r\n        if (q < 0.0) {\r\n            val = -val;\r\n        }\r\n    }\r\n\r\n    return mu + sigma * val;\r\n}\r\n\r\nfunction irr(range, guess) {\r\n    var min = -2.0;\r\n    var max = 1.0;\r\n    var n = 0;\r\n    do {\r\n        var guest = (min + max) / 2;\r\n        var NPV = 0;\r\n        for (var i = 0; i < range.length; i++) {\r\n            var arg = range[i];\r\n            NPV += arg[0] / Math.pow((1 + guest), i);\r\n        }\r\n        if (NPV > 0) {\r\n            if (min === max) {\r\n                max += Math.abs(guest);\r\n            }\r\n            min = guest;\r\n        }\r\n        else {\r\n            max = guest;\r\n        }\r\n        n++;\r\n    } while (Math.abs(NPV) > 0.000001 && n < 100000);\r\n    //console.log(n);\r\n    return guest;\r\n}\r\n\r\nfunction counta() {\r\n    var r = 0;\r\n    for (var i = arguments.length; i--;) {\r\n        var arg = arguments[i];\r\n        if (Array.isArray(arg)) {\r\n            var matrix = arg;\r\n            for (var j = matrix.length; j--;) {\r\n                for (var k = matrix[j].length; k--;) {\r\n                    if (matrix[j][k] !== null && matrix[j][k] !== undefined) {\r\n                        r++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (arg !== null && arg !== undefined) {\r\n                r++;\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction pmt(rate_per_period, number_of_payments, present_value, future_value, type) {\r\n    type = type || 0;\r\n    future_value = future_value || 0;\r\n    if (rate_per_period != 0.0) {\r\n        // Interest rate exists\r\n        var q = Math.pow(1 + rate_per_period, number_of_payments);\r\n        return -(rate_per_period * (future_value + (q * present_value))) / ((-1 + q) * (1 + rate_per_period * (type)));\r\n\r\n    }\r\n    else if (number_of_payments != 0.0) {\r\n        // No interest rate, but number of payments exists\r\n        return -(future_value + present_value) / number_of_payments;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction concatenate() {\r\n    var r = '';\r\n    for (var i = 0; i < arguments.length; i++) {\r\n        var arg = arguments[i];\r\n        if (arg === null || arg === undefined) continue;\r\n        r += arg;\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction sum() {\r\n    var r = 0;\r\n    for (var i = arguments.length; i--;) {\r\n        var arg = arguments[i];\r\n        if (Array.isArray(arg)) {\r\n            var matrix = arg;\r\n            for (var j = matrix.length; j--;) {\r\n                for (var k = matrix[j].length; k--;) {\r\n                    if (!isNaN(matrix[j][k])) {\r\n                        r += +matrix[j][k];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            r += +arg;\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction max() {\r\n    var max = null;\r\n    for (var i = arguments.length; i--;) {\r\n        var arg = arguments[i];\r\n        if (Array.isArray(arg)) {\r\n            var arr = arg;\r\n            for (var j = arr.length; j--;) {\r\n                var col = arr[j];\r\n                if (Array.isArray(col)) {\r\n                    for (var k = col.length; k--;) {\r\n                        if (max == null || (col[k] != null && max < col[k])) {\r\n                            max = col[k];\r\n                        }\r\n                    }\r\n                }\r\n                else if (max == null || (col != null && max < col)) {\r\n                    max = col;\r\n                }\r\n            }\r\n        }\r\n        else if (!isNaN(arg) && (max == null || (arg != null && max < arg))) {\r\n            max = arg;\r\n        }\r\n    }\r\n    return max;\r\n}\r\n\r\nfunction min() {\r\n    var min = null;\r\n    for (var i = arguments.length; i--;) {\r\n        var arg = arguments[i];\r\n        if (Array.isArray(arg)) {\r\n            var arr = arg;\r\n            for (var j = arr.length; j--;) {\r\n                var col = arr[j];\r\n                if (Array.isArray(col)) {\r\n                    for (var k = col.length; k--;) {\r\n                        if (min == null || (col[k] != null && min > col[k])) {\r\n                            min = col[k];\r\n                        }\r\n                    }\r\n                }\r\n                else if (min == null || (col != null && min > col)) {\r\n                    min = col;\r\n                }\r\n            }\r\n        }\r\n        else if (!isNaN(arg) && (min == null || (arg != null && min > arg))) {\r\n            min = arg;\r\n        }\r\n    }\r\n    return min;\r\n}\r\n\r\nfunction vlookup(key, matrix, return_index, range_lookup=true) {\r\n    var val = null;\r\n    for (var i = 0; i < matrix.length; i++) {\r\n        if (matrix[i][0] < key) {\r\n            val = matrix[i][return_index - 1];\r\n        }\r\n        else if (matrix[i][0] == key) {\r\n            return matrix[i][return_index - 1];\r\n        }\r\n    }\r\n    if (range_lookup && val) {\r\n        return val;\r\n    }\r\n    throw Error('#N/A');\r\n}\r\n\r\nfunction iserror() {\r\n    // if an error is catched before getting there, true will be returned from the catch block\r\n    // if we get here then it's not an error\r\n    return false;\r\n}\r\n\r\nfunction time(hours, minutes, seconds) {\r\n    const MS_PER_DAY = 24 * 60 * 60 * 1000;\r\n    return ((hours * 60 + minutes) * 60 + seconds) * 1000 / MS_PER_DAY;\r\n}\r\n\r\nfunction day(date) {\r\n    if (!date.getDate) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    var day = date.getDate();\r\n    if (isNaN(day)) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    return day;\r\n}\r\n\r\nfunction month(date) {\r\n    if (!date.getMonth) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    var month = date.getMonth();\r\n    if (isNaN(month)) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    return month + 1;\r\n}\r\n\r\nfunction year(date) {\r\n    if (!date.getFullYear) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    var year = date.getFullYear();\r\n    if (isNaN(year)) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    return year;\r\n}\r\n\r\nfunction right(text, number) {\r\n    number = (number === undefined) ? 1 : parseFloat(number);\r\n\r\n    if (isNaN(number)) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    if (text === undefined || text === null) {\r\n        text = '';\r\n    } else {\r\n        text = '' + text;\r\n    }\r\n    return text.substring(text.length - number);\r\n}\r\n\r\nfunction left(text, number) {\r\n    number = (number === undefined) ? 1 : parseFloat(number);\r\n\r\n    if (isNaN(number)) {\r\n        throw Error('#VALUE!');\r\n    }\r\n    if (text === undefined || text === null) {\r\n        text = '';\r\n    } else {\r\n        text = '' + text;\r\n    }\r\n    return text.substring(0, number);\r\n}\r\n\r\nfunction ifs(/*_cond1, _val1, _cond2, _val2, _cond3, _val3, ... */) {\r\n    for (var i = 0; i + 1 < arguments.length; i+=2) {\r\n        var cond = arguments[i];\r\n        var val = arguments[i+1];\r\n        if (cond) {\r\n            return val;\r\n        }\r\n    }\r\n    throw Error('#N/A');\r\n}\r\n\r\nfunction escapeRegExp(str) {\r\n    return str.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\r\n}\r\n\r\nfunction substitute(text, old_text, new_text, occurrence) {\r\n    if(occurrence <= 0) {\r\n      throw Error('#VALUE!');\r\n    }\r\n    if (!text || !old_text || (!new_text && new_text !== '')) {\r\n      return text;\r\n    } else if (occurrence === undefined) {\r\n      return text.replace(new RegExp(escapeRegExp(old_text), 'g'), new_text);\r\n    } else {\r\n      var index = 0;\r\n      var i = 0;\r\n      while (text.indexOf(old_text, index) > 0) {\r\n        index = text.indexOf(old_text, index + 1);\r\n        i++;\r\n        if (i === occurrence) {\r\n          return text.substring(0, index) + new_text + text.substring(index + old_text.length);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\nfunction ceiling(number, significance) {\r\n    return Math.ceil(number / significance) * significance\r\n}\r\n\r\nmodule.exports = formulas;\r\n","\"use strict\";\r\n\r\nmodule.exports = function getSanitizedSheetName(sheet_name) {\r\n    var quotedMatch = sheet_name.match(/^'(.*)'$/);\r\n    if (quotedMatch) {\r\n        return quotedMatch[1];\r\n    }\r\n    else {\r\n        return sheet_name;\r\n    }\r\n};\r\n","\"use strict\";\r\n\r\nconst int_2_col_str = require('./int_2_col_str.js');\r\nconst col_str_2_int = require('./col_str_2_int.js');\r\nconst exec_formula = require('./exec_formula.js');\r\nconst find_all_cells_with_formulas = require('./find_all_cells_with_formulas.js');\r\nconst Calculator = require('./Calculator.js');\r\n\r\nvar mymodule = function(workbook, options) {\r\n    var formulas = find_all_cells_with_formulas(workbook, exec_formula);\r\n    for (var i = formulas.length - 1; i >= 0; i--) {\r\n      try {\r\n         // console.log(formulas[i].name);\r\n        exec_formula(formulas[i]);\r\n      } catch (error) {\r\n        if (!options || !options.continue_after_error) {\r\n          throw error\r\n        }\r\n        if (options.log_error) {\r\n          console.log('error executing formula', 'sheet', formulas[i].sheet_name, 'cell', formulas[i].name, error)\r\n        }\r\n      }\r\n    }\r\n};\r\n\r\nmymodule.calculator = function calculator(workbook) {\r\n    return new Calculator(workbook, exec_formula);\r\n};\r\n\r\nmymodule.set_fx = exec_formula.set_fx;\r\nmymodule.exec_fx = exec_formula.exec_fx;\r\nmymodule.col_str_2_int = col_str_2_int;\r\nmymodule.int_2_col_str = int_2_col_str;\r\nmymodule.import_functions = exec_formula.import_functions;\r\nmymodule.import_raw_functions = exec_formula.import_raw_functions;\r\nmymodule.xlsx_Fx = exec_formula.xlsx_Fx;\r\nmymodule.localizeFunctions = exec_formula.localizeFunctions;\r\n\r\nmymodule.XLSX_CALC = mymodule\r\n\r\nmodule.exports = mymodule;\r\n","\"use strict\";\r\n\r\nmodule.exports = function int_2_col_str(n) {\r\n    var dividend = n + 1;\r\n    var columnName = '';\r\n    var modulo;\r\n    var guard = 10;\r\n    while (dividend > 0 && guard--) {\r\n        modulo = (dividend - 1) % 26;\r\n        columnName = String.fromCharCode(modulo + 65) + columnName;\r\n        dividend = (dividend - modulo - 1) / 26;\r\n    }\r\n    return columnName;\r\n};","const RawValue = require('./RawValue.js');\r\nconst RefValue = require('./RefValue.js');\r\nconst LazyValue = require('./LazyValue.js');\r\nconst Range = require('./Range.js');\r\n\r\n// this is used to _cache_ range names so that it doesn't need to be queried\r\n// every time a range is used\r\nlet definedNames, wb;\r\nfunction getDefinedName(buffer, formula) {\r\n    if (!(formula.wb.Workbook && formula.wb.Workbook.Names)) {\r\n        return null;\r\n    }\r\n    if (wb !== formula.wb) {\r\n        wb = formula.wb;\r\n        definedNames = null;\r\n        return getDefinedName(buffer, formula);\r\n    }\r\n    if (definedNames) {\r\n        return definedNames[buffer];\r\n    }\r\n    const keys = Object.values(formula.wb.Workbook.Names);\r\n    if (keys.length === 0) {\r\n        return;\r\n    }\r\n    definedNames = {};\r\n    keys.forEach(({ Name, Ref }) => {\r\n        if (!Name.includes('.')) {\r\n            definedNames[Name] = Ref;\r\n        }\r\n    });\r\n\r\n    return getDefinedName(buffer, formula);\r\n}\r\n\r\nmodule.exports = function str_2_val(buffer, formula) {\r\n    if (!isNaN(buffer)) {\r\n        return new RawValue(+buffer);\r\n    }\r\n    if (buffer === 'TRUE') {\r\n        return new RawValue(1);\r\n    }\r\n    if (typeof buffer !== 'string') {\r\n        return buffer;\r\n    }\r\n\r\n    buffer = buffer.trim().replace(/\\$/g, '')\r\n\r\n    if (buffer.match(/^[A-Z]+[0-9]+:[A-Z]+[0-9]+$/)) {\r\n        return new Range(buffer, formula);\r\n    }\r\n    if (buffer.match(/^[^!]+![A-Z]+[0-9]+:[A-Z]+[0-9]+$/)) {\r\n        return new Range(buffer, formula);\r\n    }\r\n    if (buffer.match(/^[A-Z]+:[A-Z]+$/)) {\r\n        return new Range(buffer, formula);\r\n    }\r\n    if (buffer.match(/^[^!]+![A-Z]+:[A-Z]+$/)) {\r\n        return new Range(buffer, formula);\r\n    }\r\n    if (buffer.match(/^[A-Z]+[0-9]+$/)) {\r\n        return new RefValue(buffer, formula);\r\n    }\r\n    if (buffer.match(/^[^!]+![A-Z]+[0-9]+$/)) {\r\n        return new RefValue(buffer, formula);\r\n    }\r\n    if (buffer.match(/%$/)) {\r\n        var inner = str_2_val(buffer.substr(0, buffer.length-1), formula)\r\n        return new LazyValue(() => inner.calc() / 100)\r\n    }\r\n    if (getDefinedName(buffer, formula)) {\r\n        return str_2_val(getDefinedName(buffer, formula), formula);\r\n    }\r\n    return buffer;\r\n};\r\n"],"sourceRoot":""}